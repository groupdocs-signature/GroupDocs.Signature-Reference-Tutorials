---
categories:
- Java Security
date: '2026-02-18'
description: Изучите, как шифровать Java с помощью XOR в GroupDocs.Signature. Этот
  пошаговый учебник показывает, как реализовать пользовательское шифрование, включает
  примеры кода, советы по безопасности и лучшие практики.
keywords: implement custom encryption Java, XOR encryption Java tutorial, custom signature
  encryption GroupDocs, Java document encryption, secure PDF signatures custom encryption
lastmod: '2026-02-18'
linktitle: Custom Encryption Java Guide
tags:
- encryption
- digital-signatures
- GroupDocs
- Java-tutorial
title: 'Как зашифровать Java: пользовательское XOR‑шифрование с GroupDocs'
type: docs
url: /ru/java/advanced-options/custom-xor-encryption-groupdocs-signature-java/
weight: 1
---

# Как зашифровать Java: пользовательское XOR‑шифрование с GroupDocs

## Введение

Вот ситуация, с которой вы, вероятно, уже сталкивались: вы создаёте приложение, которое должно подписывать документы в цифровом виде, но встроенные варианты шифрования не совсем подходят вашим требованиям. Возможно, вы работаете со старыми системами, которые ожидают определённый формат шифрования, или вам нужен лёгкий шифр для приложений, критичных к производительности, где тяжёлые алгоритмы вроде AES были бы избыточны.

Именно здесь вступает в игру **пользовательское шифрование** — и реализовать его проще, чем вы думаете. В этом руководстве мы пройдёмся по созданию собственного механизма шифрования, используя операцию XOR в качестве примера. Хотя XOR‑шифрование не подходит для высокозащищённых приложений (мы расскажем, когда его использовать, а когда нет), оно идеально подходит для изучения принципов **how to encrypt Java** кода и для удовлетворения нишевых интеграционных потребностей. Мы будем использовать **GroupDocs.Signature for Java**, который делает интеграцию пользовательского шифрования в ваш процесс подписи документов удивительно простой.

**Что вы узнаете:**
- Почему может понадобиться пользовательское шифрование
- Как работает XOR‑шифрование (на простом английском)
- Пошаговая реализация с GroupDocs.Signature for Java
- Реальные сценарии использования и соображения безопасности
- Распространённые ошибки и как их избежать

## Быстрые ответы
- **Что такое XOR‑шифрование?** Симметричная операция, которая инвертирует биты с помощью ключа; двойное шифрование тем же ключом восстанавливает исходные данные.  
- **Когда использовать пользовательское шифрование?** Для совместимости со старыми системами, производительной обфускации или учебных целей — не для защиты конфиденциальных данных.  
- **Какую библиотеку использует этот туториал?** GroupDocs.Signature for Java (v23.12 или новее).  
- **Нужна ли лицензия?** Бесплатная пробная версия подходит для тестов; полная лицензия требуется для продакшна.  
- **Можно ли позже заменить XOR на AES?** Да — просто замените логику `encrypt`/`decrypt`, оставив тот же интерфейс `IDataEncryption`.

## Как зашифровать Java с помощью XOR
XOR‑шифрование — классический **java xor example**, демонстрирующий основную идею симметричного шифрования. Следуя этому руководству, вы увидите, как подключить пользовательский алгоритм к рабочему процессу **GroupDocs.Signature Java**, получив полный контроль над тем, как защищаются данные подписи.

## Почему важны пользовательские шифры

Прежде чем перейти к коду, обсудим, зачем вообще может понадобиться собственное шифрование.

Большинство библиотек (включая GroupDocs) поставляются с готовыми вариантами шифрования. Так зачем писать своё? Ниже перечислены реальные сценарии, где пользовательское шифрование имеет смысл:

**Интеграция со старыми системами**: Вы работаете с устаревшими системами, которые ожидают данные, зашифрованные определённым способом. Переписывать всю систему невозможно, поэтому нужно соответствовать их методу шифрования.

**Оптимизация производительности**: Стандартные алгоритмы вроде AES безопасны, но требуют значительных вычислительных ресурсов. Для не‑чувствительных данных, которым всё‑равно нужна базовая обфускация (например, водяные знаки или внутренние идентификаторы документов), лёгкий пользовательский подход может существенно ускорить работу.

**Собственные требования**: Некоторые отрасли или клиенты требуют конкретных реализаций шифрования для соответствия нормативам или совместимости.

**Обучение и гибкость**: Понимание того, как реализовать собственное шифрование, даёт возможность оценивать решения по безопасности и адаптировать их под уникальные требования.

Тем не менее (и это важно), пользовательское шифрование никогда не должно быть первым выбором для защиты конфиденциальных данных. Для любой информации, связанной с персональными данными, финансовой информацией или регулируемым контентом, используйте проверенные алгоритмы, такие как AES‑256. Пользовательское шифрование лучше оставлять для специфических случаев, где вы полностью осознаёте компромиссы в безопасности.

## Понимание XOR: основы

Если вы не знакомы с XOR (исключающим ИЛИ), не переживайте — это один из самых простых концептов шифрования.

XOR — бинарная операция, сравнивающая два бита и возвращающая **1**, если они различаются, и **0**, если одинаковы:

- 0 XOR 0 = 0  
- 0 XOR 1 = 1  
- 1 XOR 0 = 1  
- 1 XOR 1 = 0  

Что делает XOR интересным для шифрования, так это его **симметричность**: если вы XOR‑ите данные с ключом, а затем снова XOR‑ите результат тем же ключом, вы получаете исходные данные. Это как замок, который открывается тем же ключом, которым закрывается.

Вот простой **java xor example**:

```
Original data: 5 (binary: 0101)
Key: 3 (binary: 0011)
Encrypted: 5 XOR 3 = 6 (binary: 0110)
Decrypted: 6 XOR 3 = 5 (binary: 0101) ← We're back!
```

На практике мы будем XOR‑ить каждый байт наших данных со значением ключа. Это быстро, требует минимум памяти и идеально подходит для демонстрации концепций пользовательского шифрования. Только помните: XOR с одно‑байтовым ключом легко взломать даже базовым знанием криптографии. Используйте его для обфускации, а не для защиты.

## Предварительные требования

Прежде чем реализовывать пользовательское шифрование с GroupDocs.Signature for Java, убедитесь, что у вас есть:

### Необходимые библиотеки и зависимости
- **GroupDocs.Signature for Java**: версия 23.12 или новее (API, с которым будем работать)
- **Java Development Kit**: JDK 8 или выше (рекомендовано JDK 11+ для продакшна)

### Требования к настройке окружения
- IDE: IntelliJ IDEA, Eclipse или VS Code с Java‑расширениями
- Maven или Gradle для управления зависимостями (примеры ниже работают с обоими)

### Базовые знания
- Умение писать Java‑код (классы, методы, интерфейсы)
- Базовое понимание концепций шифрования (мы только что разобрали XOR, так что всё в порядке!)
- Знание массивов байтов и побитовых операций будет плюсом, но не обязательно

Всё готово? Отлично! Приступим к настройке GroupDocs.

## Настройка GroupDocs.Signature for Java

Подключить GroupDocs к проекту просто. Выберите ваш инструмент сборки:

**Maven**  
```xml
<dependency>
    <groupId>com.groupdocs</groupId>
    <artifactId>groupdocs-signature</artifactId>
    <version>23.12</version>
</dependency>
```

**Gradle**  
```gradle
implementation 'com.groupdocs:groupdocs-signature:23.12'
```

**Прямое скачивание**  
Если предпочитаете ручную загрузку (или не можете использовать сборщик), возьмите JAR‑файл с [GroupDocs.Signature for Java releases](https://releases.groupdocs.com/signature/java/) и добавьте его в classpath проекта.

### Шаги получения лицензии

GroupDocs не бесплатен, но пробовать можно без вложений:

1. **Бесплатная проба**: скачайте и используйте все функции с некоторыми ограничениями (водяные знаки на выводе, ограничения оценки)  
2. **Временная лицензия**: запросите временную лицензию для полной оценки (идеально для POC)  
3. **Покупка**: приобретите лицензию, когда будете готовы к продакшну  

### Базовая инициализация и настройка

Вот самая простая инициализация GroupDocs — на её основе строятся все примеры:

```java
import com.groupdocs.signature.Signature;

class InitializeGroupDocs {
    public static void main(String[] args) {
        Signature signature = new Signature("path/to/your/document");
        // Additional setup and operations can be performed here.
    }
}
```

Просто, правда? Объект `Signature` — ваш главный интерфейс для всех операций подписи документов. Теперь сделаем так, чтобы он действительно что‑то шифровал.

## Руководство по реализации

### Пользовательская функция XOR‑шифрования

Переходим к реальной реализации. Мы создадим класс шифрования, который GroupDocs сможет использовать каждый раз, когда понадобится зашифровать данные подписи.

#### Шаг 1: Реализовать интерфейс IDataEncryption

GroupDocs ожидает, что обработчики шифрования реализуют интерфейс `IDataEncryption`. Это ваш контракт — реализуйте эти методы, и GroupDocs будет знать, как пользоваться вашим шифром:

```java
import com.groupdocs.signature.domain.extensions.encryption.IDataEncryption;

class CustomXOREncryption implements IDataEncryption {
    private int auto_Key;
    
    public final int getKey() {
        return auto_Key;
    }
    
    // Additional methods for encryption and decryption will be implemented here.
}
```

**Что происходит**: мы объявляем класс, обещающий предоставить функции шифрования/дешифрования. Поле `auto_Key` хранит наш XOR‑ключ (число, которым будем XOR‑ить). Метод `getKey()` позволяет другим частям кода узнать, какой ключ используется.

#### Шаг 2: Определить методы шифрования и дешифрования

Теперь сама логика шифрования. Поскольку XOR симметричен (помните?), шифрование и дешифрование — это буквально одна и та же операция:

```java
class CustomXOREncryption {
    private int auto_Key;

    public byte[] encrypt(byte[] data) {
        if (auto_Key == 0 || data == null) return data;
        
        byte[] result = new byte[data.length];
        for (int i = 0; i < data.length; i++) {
            result[i] = (byte) (data[i] ^ auto_Key);
        }
        return result;
    }

    public byte[] decrypt(byte[] encryptedData) {
        // Since XOR is symmetric, use the same method as encryption
        return encrypt(encryptedData);
    }
}
```

**Разбор кода:**
- Проверяем, не равен ли ключ нулю (это было бы бесполезно) и не получены ли `null`‑данные (чтобы избежать падений)  
- Создаём новый массив байтов для результата  
- Проходим по каждому байту входных данных  
- Для каждого байта делаем XOR с нашим ключом: `data[i] ^ auto_Key`  
- Приведение к `(byte)` необходимо, потому что XOR в Java возвращает `int`, а нам нужны байты  

Красота XOR: `decrypt()` просто вызывает `encrypt()` ещё раз. Операция, которая запутывает данные, одновременно их и распутывает!

### Параметры конфигурации ключа

**auto_Key**: ваш ключ шифрования. Важные моменты:

- Должен быть отличным от нуля (XOR с 0 ничего не меняет)  
- Для одно‑байтового XOR рекомендуется диапазон 1‑255 (значения выше 255 используют только младшие 8 бит)  
- В реальных приложениях стоит делать его настраиваемым через переменные окружения или файлы конфигурации  
- Для продакшна понадобится более продвинутая система управления ключами  

Пример установки:

```java
CustomXOREncryption encryption = new CustomXOREncryption();
encryption.setKey(42); // Any non-zero value works
```

### Распространённые ошибки реализации

Сэкономим вам время отладки. Вот типичные ошибки, которые я встречал (и сам делал):

**Ошибка #1: Не установлен ключ**  
```java
CustomXOREncryption encryption = new CustomXOREncryption();
// Oops! Never called setKey(), so auto_Key is 0
byte[] encrypted = encryption.encrypt(myData); // Returns data unchanged!
```  
**Исправление**: всегда инициализируйте ключ перед использованием шифра.

**Ошибка #2: Не обработаны `null`‑данные**  
Без проверки `if (data == null) return data;` вы получите `NullPointerException` в самый неподходящий момент.

**Ошибка #3: Считают XOR безопасным**  
Этот шифр легко взломать. Если кто‑то знает (или угадает) часть открытого текста, он может вывести ваш ключ. Используйте его только для обфускации, а не для защиты.

**Ошибка #4: Используется неверный ключ для дешифрования**  
Поскольку для дешифрования нужен тот же ключ, его потеря или изменение приводит к безвозвратной потере данных. В продакшне нужен надёжный менеджмент ключей и стратегии резервного копирования.

## Соображения по безопасности

Поговорим откровенно о безопасности, потому что это важно:

**XOR‑шифрование НЕ безопасно для конфиденциальных данных**  

Повторяю: одно‑байтовый XOR‑шифр, как мы реализовали, может быть взломан за секунды любым, кто знает основы криптографии. Почему:

1. **Анализ частот** — если атакующий знает формат ваших данных, он может предположить вероятные байты и вывести ваш ключ.  
2. **Атаки с известным открытым текстом** — знание даже небольшого фрагмента открытого текста позволяет получить ключ простым XOR.  
3. **Перебор** — всего 255 возможных ключей, их проверка занимает миллисекунды.  

**Когда уместен XOR‑шифр:**  

- Обфускация внутренних идентификаторов, не являющихся чувствительными  
- Быстрая «запутывающая» обработка для кэш‑ключей или временных данных  
- Обучение принципам шифрования  
- Выполнение требований старых систем, использующих XOR  
- Приложения, где безопасность обеспечивается другими уровнями, а требуется только лёгкая обработка  

**Когда использовать настоящее шифрование:**  

- Персональная информация (имена, email, адреса)  
- Финансовые данные  
- Медицинская информация  
- Учётные данные (пароли, токены)  
- Любые данные, подпадающие под регулятивные нормы (GDPR, HIPAA, PCI‑DSS)  

**Лучшие альтернативы:**  

- **AES‑256** — отраслевой стандарт, отличное соотношение безопасность‑производительность  
- **RSA** — хорош для шифрования небольших объёмов, например, ключей шифрования  
- **ChaCha20** — современная альтернатива AES, иногда быстрее на мобильных устройствах  

Хорошая новость: паттерн, который мы используем (интерфейс `IDataEncryption`), одинаково работает с любым алгоритмом шифрования. Вы можете заменить XOR на AES, просто изменив методы `encrypt` и `decrypt`.

## Практические применения

Теперь, когда мы разобрали «что» и «почему», перейдём к реальным сценариям использования:

### 1. Защищённый рабочий процесс подписи документов

Представьте систему управления контрактами, где документы требуют цифровой подписи, но метаданные подписи (ID подписанта, метка времени, отдел) нужно слегка запутать перед хранением:

```java
Signature signature = new Signature("contract.pdf");
CustomXOREncryption encryption = new CustomXOREncryption();
encryption.setKey(73); // Configure your key

// GroupDocs will use your encryption for signature data
// (Actual integration depends on specific GroupDocs API methods)
```

**Практический выигрыш**: ваша база не содержит открытого текста метаданных, которые могли бы быть случайно выведены из логов.

### 2. Проверка целостности данных

Можно использовать пользовательское шифрование как лёгкую проверку целостности. Зашифруйте известное значение, сохраните его вместе с документом, а затем расшифруйте и проверьте:

```java
String integrityToken = "VALID_SIGNATURE_2025";
byte[] encrypted = encryption.encrypt(integrityToken.getBytes());
// Store encrypted with document...
// Later, decrypt and compare to verify nothing changed
```

Это не криптографический уровень целостности (для этого используйте HMAC), но помогает отлавливать случайные повреждения.

### 3. Интеграция со старыми системами

Самый распространённый реальный случай. Вы модернизируете приложение, но оно должно взаимодействовать с системой начала 2000‑х, ожидающей XOR‑зашифрованные данные:

```java
// Old system expects data encrypted with XOR key 42
CustomXOREncryption legacyEncryption = new CustomXOREncryption();
legacyEncryption.setKey(42);

// Encrypt data before sending to legacy system
byte[] dataForOldSystem = legacyEncryption.encrypt(modernData);
sendToLegacyAPI(dataForOldSystem);
```

Вы не выбираете XOR потому, что он лучше — вы выбираете его, потому что именно такой формат понимает другая система.

## Соображения по производительности

Одна из причин использовать лёгкое шифрование, вроде XOR, — производительность. Однако даже простые операции могут стать узким местом, если их неправильно использовать. На что обратить внимание:

### Оптимизация производительности

**Для небольших данных (< 1 KB)** — реализация XOR выше подходит, накладные расходы пренебрежимо малы.

**Для больших документов (> 10 MB)** — рассмотрите следующие оптимизации:

1. **Обработка блоками** — вместо XOR‑а всего документа сразу, делайте это порциями (например, по 4 KB).  
2. **Параллельная обработка** — для очень больших файлов разбейте работу на несколько потоков.  
3. **Избегайте лишних копий** — наша реализация создаёт новый массив байтов, что удваивает временное потребление памяти.

```java
// More memory‑efficient for large data
public void encryptInPlace(byte[] data) {
    if (auto_Key == 0 || data == null) return;
    
    for (int i = 0; i < data.length; i++) {
        data[i] = (byte) (data[i] ^ auto_Key);
    }
}
```

### Руководство по использованию ресурсов

**Память** — текущая реализация требует:

- Оригинальный массив данных в памяти  
- Зашифрованный массив данных в памяти (тот же размер)  
- Временные объекты во время обработки  

Для документа в 50 MB ожидайте около 100 MB памяти во время шифрования.

**CPU** — XOR чрезвычайно быстрый: обычно менее 1 мс для небольших файлов (< 100 KB). Приблизительные оценки на современном железе:

- 1 MB ≈ 10 мс  
- 10 MB ≈ 100 мс  
- 100 MB ≈ 1 с  

Эти цифры зависят от процессора, скорости памяти и оптимизаций JVM.

### Лучшие практики управления памятью в Java

При работе с шифрованием в Java помните:

1. **Очищайте чувствительные данные** — после использования ключа или расшифрованных данных явно обнуляйте их:  
   ```java
   Arrays.fill(decryptedData, (byte) 0); // Overwrite with zeros
   ```  
2. **Используйте try‑with‑resources** — гарантирует автоматическое закрытие потоков:  
   ```java
   try (FileInputStream fis = new FileInputStream("encrypted.dat")) {
       // Process data
   } // Automatically closed
   ```  
3. **Следите за использованием кучи** — для приложений, обрабатывающих множество документов, рассмотрите `-XX:+UseG1GC` для более эффективного сборщика.  
4. **Не используйте String для бинарных данных** — никогда не преобразовывайте зашифрованные байты в `String` и обратно — это испортит данные. Оставляйте их в виде массивов байтов.

## Устранение распространённых проблем

### Проблема 1: «Данные после дешифрования выглядят как мусор»

**Симптом** — после дешифрования получаются случайные байты вместо оригинала.  

**Причины** — использован другой ключ, данные повреждены при хранении/транспорте, либо произошла конверсия байтов в `String`.  

**Решение** — убедитесь, что используете точно такой же ключ, и храните данные как массивы байтов на всех этапах.

### Проблема 2: «NullPointerException во время шифрования»

**Симптом** — падение с `NullPointerException` при вызове `encrypt()`.  

**Причина** — в метод переданы `null`‑данные.  

**Решение** — всегда проверяйте `null` в методах `encrypt`/`decrypt` (как показано в реализации).

### Проблема 3: «Шифрование, кажется, не работает»

**Симптом** — зашифрованные данные выглядят идентично открытым.  

**Причина** — ключ равен `0` или не установлен.  

**Решение** — добавьте проверку во время разработки:  
```java
assert auto_Key != 0 : "Encryption key must be set!";
```

### Проблема 4: «OutOfMemoryError при работе с большими файлами»

**Симптом** — приложение падает при шифровании больших документов.  

**Причина** — загрузка всего файла в память сразу.  

**Решение** — обрабатывать файлы потоками/блоками:  

```java
try (FileInputStream in = new FileInputStream(path);
     FileOutputStream out = new FileOutputStream(encryptedPath)) {
    byte[] buffer = new byte[4096];
    int bytesRead;
    while ((bytesRead = in.read(buffer)) != -1) {
        encryptInPlace(buffer, 0, bytesRead);
        out.write(buffer, 0, bytesRead);
    }
}
```

## Заключение

Мы прошли большой путь! Теперь вы знаете **how to encrypt Java** с помощью XOR как учебного примера, интегрировали его в GroupDocs.Signature и понимаете, когда (и когда не) использовать пользовательские подходы к шифрованию.

**Ключевые выводы**
- Пользовательское шифрование полезно в специфических сценариях (старые системы, требования к производительности, обучение)  
- XOR отлично подходит для понимания принципов, но не для защиты чувствительных данных  
- GroupDocs.Signature упрощает интеграцию через интерфейс `IDataEncryption`  
- Всегда оценивайте последствия для безопасности, прежде чем писать собственный шифр  

**Следующие шаги**

1. **Реализовать AES‑шифрование** — замените логику `CustomXOREncryption` на AES (пакет `javax.crypto` упрощает задачу).  
2. **Внедрить ротацию ключей** — построьте систему, позволяющую менять ключи без потери доступа к уже зашифрованным данным.  
3. **Исследовать дополнительные возможности GroupDocs** — проверка подписи, создание шаблонов, многоподписные рабочие процессы.

Паттерн, который вы освоили — реализация интерфейса для кастомного поведения — используется по всему API GroupDocs. Овладейте им, и вы сможете адаптировать библиотеку под любые нужды.

А теперь — зашифруйте что‑нибудь! (Только убедитесь, что это не то, что действительно нужно защищать, пока не перейдёте на настоящий алгоритм шифрования.)

## Раздел FAQ

### 1. Как выбрать подходящий XOR‑ключ?
Для XOR любой ненулевой целочисленный параметр подходит, но сам по себе ключ не добавляет безопасности. Если вам действительно нужна защита, откажитесь от XOR и перейдите на AES или другой проверенный алгоритм. Для обфускации просто возьмите случайное значение от 1 до 255 и храните его в конфигурации.

### 2. Можно ли менять XOR‑ключ динамически во время работы?
Да! Просто вызовите `setKey()` с новым значением. Но помните: любые данные, зашифрованные старым ключом, нужно будет расшифровать старым ключом. При смене ключей потребуется пере‑шифровать существующие данные или вести учёт, какой ключ использовался где. Именно поэтому управление ключами — отдельная дисциплина в криптографии.

### 3. Какие есть альтернативы XOR‑шифрованию?
Для учебных и незащищённых целей: шифр Цезаря, ROT13, base64 (это не шифрование, а лишь обфускация).  

Для реальной защиты: AES‑256 (симметричный), RSA‑2048+ (асимметричный), ChaCha20 (современный симметричный). Все они поддерживаются в Java через пакет `javax.crypto`.

### 4. Как GroupDocs.Signature обрабатывает большие файлы с шифрованием?
GroupDocs оптимизирован для больших файлов и использует потоковую обработку, где это возможно. Однако ваша пользовательская реализация шифрования может стать узким местом, если вы не будете осторожны. Для файлов более 50 MB рекомендуется реализовать обработку блоками в методах `encrypt`/`decrypt`, а не загружать всё в память сразу.

### 5. Можно ли интегрировать эту функцию в веб‑приложение?
Определённо! Используйте Spring Boot, Jakarta EE или любой другой Java‑фреймворк. Несколько советов:  

- Сделайте класс шифрования синглтоном или bean‑ом уровня приложения  
- Храните ключ в переменных окружения, а не в коде  
- Шифруйте данные перед их отправкой из сервера  
- Следите за потреблением памяти при одновременной загрузке больших файлов несколькими пользователями  

Пример интеграции в Spring Boot:

```java
@Component
public class EncryptionService {
    private CustomXOREncryption encryption;
    
    public EncryptionService(@Value("${app.encryption.key}") int key) {
        this.encryption = new CustomXOREncryption();
        this.encryption.setKey(key);
    }
    // Use in your controllers...
}
```

### 6. Можно ли применять это к PDF‑документам?
Да! GroupDocs.Signature поддерживает PDF, а также Word, Excel, изображения и прочие форматы. Шифрование происходит на уровне данных подписи, а не всего документа, поэтому работает с любым поддерживаемым форматом.

### 7. Что происходит, если я потеряю ключ шифрования?
При симметричном шифровании (как XOR) потеря ключа означает безвозвратную потерю данных. Восстановления нет. В продакшн‑системах обычно используют:  

- Системы резервного копирования ключей  
- Эскроу‑ключи для регулируемых отраслей  
- Политику ротации ключей с перекрывающимися периодами  
- Журналы аудита использования ключей  

Это ещё одна причина использовать проверенные библиотеки шифрования — они уже включают инструменты управления ключами.

## Ресурсы

- [GroupDocs.Signature for Java Documentation](https://docs.groupdocs.com/signature/java/)  
- [API Reference](https://reference.groupdocs.com/signature/java/)  
- [Latest Release Download](https://releases.groupdocs.com/signature/java/)  
- [Purchase License](https://purchase.groupdocs.com/buy)  
- [Free Trial](https://releases.groupdocs.com/signature/java/)  
- [Temporary License Request](https://purchase.groupdocs.com/temporary-license/)  
- [GroupDocs Support Forum](https://forum.groupdocs.com/c/signature/)

---

**Последнее обновление:** 2026-02-18  
**Тестировано с:** GroupDocs.Signature 23.12 for Java  
**Автор:** GroupDocs